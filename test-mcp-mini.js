/**
 * Mini MCP Test Scenarios
 * Bu dosyayÄ± Ã§alÄ±ÅŸtÄ±rmak iÃ§in proxy server'Ä±n ayakta olmasÄ± gerekir
 */

const MCP_BASE = 'http://127.0.0.1:3001/mcp';

// Renkli console Ã§Ä±ktÄ±larÄ±
const log = {
    success: (msg) => console.log(`\x1b[32mâœ… ${msg}\x1b[0m`),
    error: (msg) => console.log(`\x1b[31mâŒ ${msg}\x1b[0m`),
    info: (msg) => console.log(`\x1b[34mâ„¹ï¸  ${msg}\x1b[0m`),
    warn: (msg) => console.log(`\x1b[33mâš ï¸  ${msg}\x1b[0m`)
};

/**
 * Test 1: Health Check
 */
async function testHealth() {
    log.info('Test 1: Health Check');
    
    try {
        const response = await fetch(`${MCP_BASE}/health`);
        const data = await response.json();
        
        if (data.ok) {
            log.success(`MCP Ã§evrimiÃ§i (uptime: ${data.uptime.toFixed(2)}s)`);
            log.info(`Workdir: ${data.workdir}`);
            log.info(`Allowed commands: ${data.allowedCommands.join(', ')}`);
            return true;
        } else {
            log.error('MCP health check baÅŸarÄ±sÄ±z');
            return false;
        }
    } catch (error) {
        log.error(`MCP ulaÅŸÄ±lamÄ±yor: ${error.message}`);
        return false;
    }
}

/**
 * Test 2: FS Write + Read
 */
async function testFileSystem() {
    log.info('Test 2: FS Write + Read');
    
    const testData = `// Test file generated by MCP\nconst test = "Hello MCP";\nconsole.log(test);\n`;
    
    try {
        // Write
        const writeResponse = await fetch(`${MCP_BASE}/fs/write`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                path: 'test-mcp-output.js',
                data: testData
            })
        });
        
        const writeResult = await writeResponse.json();
        
        if (!writeResult.ok) {
            log.error(`Write baÅŸarÄ±sÄ±z: ${writeResult.error}`);
            return false;
        }
        
        log.success(`Dosya yazÄ±ldÄ±: ${writeResult.path} (${writeResult.size} bytes)`);
        
        // Read
        const readResponse = await fetch(`${MCP_BASE}/fs/read`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                path: 'test-mcp-output.js'
            })
        });
        
        const readResult = await readResponse.json();
        
        if (!readResult.ok) {
            log.error(`Read baÅŸarÄ±sÄ±z: ${readResult.error}`);
            return false;
        }
        
        if (readResult.data === testData) {
            log.success('Dosya doÄŸru okundu');
            return true;
        } else {
            log.error('Dosya iÃ§eriÄŸi uyuÅŸmuyor');
            return false;
        }
        
    } catch (error) {
        log.error(`FS test hatasÄ±: ${error.message}`);
        return false;
    }
}

/**
 * Test 3: Placeholder Detection
 */
async function testPlaceholder() {
    log.info('Test 3: Placeholder Detection');
    
    const badData = `const component = () => {\n  // TODO: implement this\n  return null;\n};\n`;
    
    try {
        const response = await fetch(`${MCP_BASE}/fs/write`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                path: 'test-bad.js',
                data: badData
            })
        });
        
        const result = await response.json();
        
        if (!result.ok && result.error.includes('Placeholder')) {
            log.success(`Placeholder engellendi: "${result.detected}"`);
            return true;
        } else {
            log.error('Placeholder engel sistemi Ã§alÄ±ÅŸmÄ±yor');
            return false;
        }
        
    } catch (error) {
        log.error(`Placeholder test hatasÄ±: ${error.message}`);
        return false;
    }
}

/**
 * Test 4: Shell Run (Whitelist)
 */
async function testShellWhitelist() {
    log.info('Test 4: Shell Whitelist');
    
    try {
        // âœ… Ä°zin verilen komut
        const goodResponse = await fetch(`${MCP_BASE}/shell/run`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                cmd: 'node',
                args: ['--version']
            })
        });
        
        const goodResult = await goodResponse.json();
        
        if (goodResult.ok) {
            log.success(`Node.js versiyonu: ${goodResult.stdout.trim()}`);
        } else {
            log.error('Ä°zin verilen komut baÅŸarÄ±sÄ±z');
            return false;
        }
        
        // âŒ Ä°zin verilmeyen komut
        const badResponse = await fetch(`${MCP_BASE}/shell/run`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                cmd: 'rm',
                args: ['-rf', '/']
            })
        });
        
        const badResult = await badResponse.json();
        
        if (!badResult.ok && badResult.error.includes('izin listesinde deÄŸil')) {
            log.success('Tehlikeli komut engellendi');
            return true;
        } else {
            log.error('Whitelist sistemi Ã§alÄ±ÅŸmÄ±yor!');
            return false;
        }
        
    } catch (error) {
        log.error(`Shell test hatasÄ±: ${error.message}`);
        return false;
    }
}

/**
 * Test 5: Context Guard
 */
async function testContextGuard() {
    log.info('Test 5: Context Guard');
    
    try {
        const response = await fetch(`${MCP_BASE}/context/guard`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                cwd: '.'
            })
        });
        
        const result = await response.json();
        
        if (result.ok) {
            log.success(`Framework tespit edildi: ${result.framework}`);
            if (result.rules.length > 0) {
                log.info(`Kurallar: ${result.rules.length} adet`);
                result.rules.forEach(rule => {
                    log.info(`  - [${rule.type}] ${rule.pattern}: ${rule.reason}`);
                });
            }
            return true;
        } else {
            log.error('Context guard baÅŸarÄ±sÄ±z');
            return false;
        }
        
    } catch (error) {
        log.error(`Context guard test hatasÄ±: ${error.message}`);
        return false;
    }
}

/**
 * Test 6: Build (package.json kontrolÃ¼)
 */
async function testBuild() {
    log.info('Test 6: Build');
    
    try {
        const response = await fetch(`${MCP_BASE}/build`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                cwd: '.'
            })
        });
        
        const result = await response.json();
        
        if (result.skip) {
            log.warn(`Build atlandÄ±: ${result.reason}`);
            return true; // Skip durumu baÅŸarÄ±lÄ± sayÄ±lÄ±r
        } else if (result.ok) {
            log.success('Build baÅŸarÄ±lÄ±');
            if (result.context) {
                log.info(`Framework: ${result.context.framework}`);
            }
            return true;
        } else {
            log.error(`Build baÅŸarÄ±sÄ±z (exit code: ${result.code})`);
            if (result.stderr) {
                console.log('\nStderr (son 200 karakter):');
                console.log(result.stderr.slice(-200));
            }
            return false;
        }
        
    } catch (error) {
        log.error(`Build test hatasÄ±: ${error.message}`);
        return false;
    }
}

/**
 * Test 7: Probe (localhost check)
 */
async function testProbe() {
    log.info('Test 7: Probe');
    
    try {
        // Proxy server'Ä±n kendisini probe et
        const response = await fetch(`${MCP_BASE}/probe`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                url: 'http://127.0.0.1:3001/health',
                timeout: 3000
            })
        });
        
        const result = await response.json();
        
        if (result.ok && result.status === 200) {
            log.success(`Probe baÅŸarÄ±lÄ± (${result.status} ${result.statusText})`);
            log.info(`Body length: ${result.bodyLength} bytes`);
            return true;
        } else {
            log.error(`Probe baÅŸarÄ±sÄ±z: ${result.error || result.status}`);
            return false;
        }
        
    } catch (error) {
        log.error(`Probe test hatasÄ±: ${error.message}`);
        return false;
    }
}

/**
 * TÃ¼m testleri Ã§alÄ±ÅŸtÄ±r
 */
async function runAllTests() {
    console.log('\nğŸ”§ Mini MCP Test Suite\n');
    console.log('='.repeat(50));
    
    const tests = [
        { name: 'Health Check', fn: testHealth },
        { name: 'File System', fn: testFileSystem },
        { name: 'Placeholder Detection', fn: testPlaceholder },
        { name: 'Shell Whitelist', fn: testShellWhitelist },
        { name: 'Context Guard', fn: testContextGuard },
        { name: 'Build', fn: testBuild },
        { name: 'Probe', fn: testProbe }
    ];
    
    let passed = 0;
    let failed = 0;
    
    for (const test of tests) {
        console.log('');
        const result = await test.fn();
        if (result) {
            passed++;
        } else {
            failed++;
        }
    }
    
    console.log('\n' + '='.repeat(50));
    console.log(`\nğŸ“Š SonuÃ§: ${passed} baÅŸarÄ±lÄ±, ${failed} baÅŸarÄ±sÄ±z\n`);
    
    if (failed === 0) {
        log.success('TÃ¼m testler baÅŸarÄ±lÄ±! ğŸ‰');
    } else {
        log.error(`${failed} test baÅŸarÄ±sÄ±z oldu.`);
    }
}

// Ã‡alÄ±ÅŸtÄ±r
runAllTests().catch(console.error);
