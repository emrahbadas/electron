/**
 * Mini MCP Test Scenarios
 * Bu dosyayı çalıştırmak için proxy server'ın ayakta olması gerekir
 */

const MCP_BASE = 'http://127.0.0.1:3001/mcp';

// Renkli console çıktıları
const log = {
    success: (msg) => console.log(`\x1b[32m✅ ${msg}\x1b[0m`),
    error: (msg) => console.log(`\x1b[31m❌ ${msg}\x1b[0m`),
    info: (msg) => console.log(`\x1b[34mℹ️  ${msg}\x1b[0m`),
    warn: (msg) => console.log(`\x1b[33m⚠️  ${msg}\x1b[0m`)
};

/**
 * Test 1: Health Check
 */
async function testHealth() {
    log.info('Test 1: Health Check');
    
    try {
        const response = await fetch(`${MCP_BASE}/health`);
        const data = await response.json();
        
        if (data.ok) {
            log.success(`MCP çevrimiçi (uptime: ${data.uptime.toFixed(2)}s)`);
            log.info(`Workdir: ${data.workdir}`);
            log.info(`Allowed commands: ${data.allowedCommands.join(', ')}`);
            return true;
        } else {
            log.error('MCP health check başarısız');
            return false;
        }
    } catch (error) {
        log.error(`MCP ulaşılamıyor: ${error.message}`);
        return false;
    }
}

/**
 * Test 2: FS Write + Read
 */
async function testFileSystem() {
    log.info('Test 2: FS Write + Read');
    
    const testData = `// Test file generated by MCP\nconst test = "Hello MCP";\nconsole.log(test);\n`;
    
    try {
        // Write
        const writeResponse = await fetch(`${MCP_BASE}/fs/write`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                path: 'test-mcp-output.js',
                data: testData
            })
        });
        
        const writeResult = await writeResponse.json();
        
        if (!writeResult.ok) {
            log.error(`Write başarısız: ${writeResult.error}`);
            return false;
        }
        
        log.success(`Dosya yazıldı: ${writeResult.path} (${writeResult.size} bytes)`);
        
        // Read
        const readResponse = await fetch(`${MCP_BASE}/fs/read`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                path: 'test-mcp-output.js'
            })
        });
        
        const readResult = await readResponse.json();
        
        if (!readResult.ok) {
            log.error(`Read başarısız: ${readResult.error}`);
            return false;
        }
        
        if (readResult.data === testData) {
            log.success('Dosya doğru okundu');
            return true;
        } else {
            log.error('Dosya içeriği uyuşmuyor');
            return false;
        }
        
    } catch (error) {
        log.error(`FS test hatası: ${error.message}`);
        return false;
    }
}

/**
 * Test 3: Placeholder Detection
 */
async function testPlaceholder() {
    log.info('Test 3: Placeholder Detection');
    
    const badData = `const component = () => {\n  // TODO: implement this\n  return null;\n};\n`;
    
    try {
        const response = await fetch(`${MCP_BASE}/fs/write`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                path: 'test-bad.js',
                data: badData
            })
        });
        
        const result = await response.json();
        
        if (!result.ok && result.error.includes('Placeholder')) {
            log.success(`Placeholder engellendi: "${result.detected}"`);
            return true;
        } else {
            log.error('Placeholder engel sistemi çalışmıyor');
            return false;
        }
        
    } catch (error) {
        log.error(`Placeholder test hatası: ${error.message}`);
        return false;
    }
}

/**
 * Test 4: Shell Run (Whitelist)
 */
async function testShellWhitelist() {
    log.info('Test 4: Shell Whitelist');
    
    try {
        // ✅ İzin verilen komut
        const goodResponse = await fetch(`${MCP_BASE}/shell/run`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                cmd: 'node',
                args: ['--version']
            })
        });
        
        const goodResult = await goodResponse.json();
        
        if (goodResult.ok) {
            log.success(`Node.js versiyonu: ${goodResult.stdout.trim()}`);
        } else {
            log.error('İzin verilen komut başarısız');
            return false;
        }
        
        // ❌ İzin verilmeyen komut
        const badResponse = await fetch(`${MCP_BASE}/shell/run`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                cmd: 'rm',
                args: ['-rf', '/']
            })
        });
        
        const badResult = await badResponse.json();
        
        if (!badResult.ok && badResult.error.includes('izin listesinde değil')) {
            log.success('Tehlikeli komut engellendi');
            return true;
        } else {
            log.error('Whitelist sistemi çalışmıyor!');
            return false;
        }
        
    } catch (error) {
        log.error(`Shell test hatası: ${error.message}`);
        return false;
    }
}

/**
 * Test 5: Context Guard
 */
async function testContextGuard() {
    log.info('Test 5: Context Guard');
    
    try {
        const response = await fetch(`${MCP_BASE}/context/guard`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                cwd: '.'
            })
        });
        
        const result = await response.json();
        
        if (result.ok) {
            log.success(`Framework tespit edildi: ${result.framework}`);
            if (result.rules.length > 0) {
                log.info(`Kurallar: ${result.rules.length} adet`);
                result.rules.forEach(rule => {
                    log.info(`  - [${rule.type}] ${rule.pattern}: ${rule.reason}`);
                });
            }
            return true;
        } else {
            log.error('Context guard başarısız');
            return false;
        }
        
    } catch (error) {
        log.error(`Context guard test hatası: ${error.message}`);
        return false;
    }
}

/**
 * Test 6: Build (package.json kontrolü)
 */
async function testBuild() {
    log.info('Test 6: Build');
    
    try {
        const response = await fetch(`${MCP_BASE}/build`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                cwd: '.'
            })
        });
        
        const result = await response.json();
        
        if (result.skip) {
            log.warn(`Build atlandı: ${result.reason}`);
            return true; // Skip durumu başarılı sayılır
        } else if (result.ok) {
            log.success('Build başarılı');
            if (result.context) {
                log.info(`Framework: ${result.context.framework}`);
            }
            return true;
        } else {
            log.error(`Build başarısız (exit code: ${result.code})`);
            if (result.stderr) {
                console.log('\nStderr (son 200 karakter):');
                console.log(result.stderr.slice(-200));
            }
            return false;
        }
        
    } catch (error) {
        log.error(`Build test hatası: ${error.message}`);
        return false;
    }
}

/**
 * Test 7: Probe (localhost check)
 */
async function testProbe() {
    log.info('Test 7: Probe');
    
    try {
        // Proxy server'ın kendisini probe et
        const response = await fetch(`${MCP_BASE}/probe`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                url: 'http://127.0.0.1:3001/health',
                timeout: 3000
            })
        });
        
        const result = await response.json();
        
        if (result.ok && result.status === 200) {
            log.success(`Probe başarılı (${result.status} ${result.statusText})`);
            log.info(`Body length: ${result.bodyLength} bytes`);
            return true;
        } else {
            log.error(`Probe başarısız: ${result.error || result.status}`);
            return false;
        }
        
    } catch (error) {
        log.error(`Probe test hatası: ${error.message}`);
        return false;
    }
}

/**
 * Tüm testleri çalıştır
 */
async function runAllTests() {
    console.log('\n🔧 Mini MCP Test Suite\n');
    console.log('='.repeat(50));
    
    const tests = [
        { name: 'Health Check', fn: testHealth },
        { name: 'File System', fn: testFileSystem },
        { name: 'Placeholder Detection', fn: testPlaceholder },
        { name: 'Shell Whitelist', fn: testShellWhitelist },
        { name: 'Context Guard', fn: testContextGuard },
        { name: 'Build', fn: testBuild },
        { name: 'Probe', fn: testProbe }
    ];
    
    let passed = 0;
    let failed = 0;
    
    for (const test of tests) {
        console.log('');
        const result = await test.fn();
        if (result) {
            passed++;
        } else {
            failed++;
        }
    }
    
    console.log('\n' + '='.repeat(50));
    console.log(`\n📊 Sonuç: ${passed} başarılı, ${failed} başarısız\n`);
    
    if (failed === 0) {
        log.success('Tüm testler başarılı! 🎉');
    } else {
        log.error(`${failed} test başarısız oldu.`);
    }
}

// Çalıştır
runAllTests().catch(console.error);
